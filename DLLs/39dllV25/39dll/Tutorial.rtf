{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f36\froman\fcharset238\fprq2 Times New Roman CE;}{\f37\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f39\froman\fcharset161\fprq2 Times New Roman Greek;}{\f40\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f41\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f42\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f43\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f44\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\f46\fswiss\fcharset238\fprq2 Arial CE;}{\f47\fswiss\fcharset204\fprq2 Arial Cyr;}{\f49\fswiss\fcharset161\fprq2 Arial Greek;}{\f50\fswiss\fcharset162\fprq2 Arial Tur;}{\f51\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f52\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f53\fswiss\fcharset186\fprq2 Arial Baltic;}{\f54\fswiss\fcharset163\fprq2 Arial (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\rsidtbl \rsid4865889}{\*\generator Microsoft Word 10.0.2627;}{\info{\author Luke}
{\operator Luke}{\creatim\yr2005\mo12\dy26\hr23\min34}{\revtim\yr2005\mo12\dy26\hr23\min35}{\version2}{\edmins1}{\nofpages5}{\nofwords1375}{\nofchars7838}{\*\company .}{\nofcharsws9195}{\vern16437}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale100\nolnhtadjtbl\rsidroot4865889 \fet0\sectd 
\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}
{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs28\insrsid4865889 Winsock Tutorial using the dll made by 39ster
\par 
\par }{\b\f1\insrsid4865889 2 player pong
\par 
\par }{\f1\insrsid4865889 In this tutorial i will teach you how to use my winsock dll to create a online game. I will use
\par Pong as my example game.
\par 
\par }{\b\f1\insrsid4865889 Initializing the dll.
\par }{\f1\insrsid4865889 For the dll to function you need to link the functions inside the dll to your game. To do this simply put in the
\par creation code of the first room:
\par dllinit(0, true, false);
\par 
\par If the first argument is a number then the dll will load the dll file "39dll.dll". If this is a string then the string will be
\par the name of the dll. e.g If the first argument is "sock.dll" then the dll file must be named "sock.dll" and it will load it
\par using that filename.
\par The second argument is true if you want to use winsock. In this case we do. The third argument should only be
\par true if we want to use the file functions. In this example this is not needed so we wont load those functions from the
\par dll.
\par 
\par }{\b\f1\fs40\insrsid4865889 Setting up the server.}{\b\f1\insrsid4865889 
\par }{\f1\insrsid4865889 To create a multiplayer game, one person needs to host the server and the other person needs to connect.
\par To set up a server using my dll you first need to create an object which controls the setting up of the server
\par and accepting any new connection. What you will need to do is create a menu that has 2 buttons. The first
\par button says "Host" and the second button should say "Connect". When the user selects host, make it execute
\par this code "global.master = true;" and make the room change to a room called "rmWaiting". Create a new 
\par object and call it "objWait". In the create event of this object add this code:
\par 
\par }{\i\f1\fs20\insrsid4865889 listen = tcplisten(14804, 2, true);
\par if(listen <= 0)
\par \{
\par   show_message("Failed to listen on port 14804");
\par   game_end();
\par \}}{\i\f1\insrsid4865889 
\par 
\par }{\f1\insrsid4865889 What that piece of code does is create a listening socket that will listen for any incomming connections on port
\par 14804. The port number can be whatever you want but i have used 14804. The second argument is the maximum
\par allowed connections in the waiting list. This is not the maximum allowed people in the game. When someone tries
\par to connect they are put on the waiting list until the server accepts them. The last argument is set to true because
\par we want the listening socket to not freeze the game when you are using the tcpaccept script and no one is has tried
\par to connect. The script will return a socket identifier number that is bigger than 0 if we succeded. A number <= 0 is returned
\par if an error occured.
\par The next line checks if we are succesfully listening on port 14804. If the socket identifier is smaller than or equal to 0 then
\par an error occur so we end the game.
\par 
\par }{\b\f1\insrsid4865889 Accepting new connections. 
\par }{\f1\insrsid4865889 To accept new connections you need to create a step event for the "objWait" object we created. In the step event add this code:
\par }{\f1\fs20\insrsid4865889 
\par }{\i\f1\fs20\insrsid4865889 client = tcpaccept(listen, true);
\par if(client <= 0) exit;
\par global.otherplayer = client;
\par room_goto(rmGame);
\par 
\par }{\f1\insrsid4865889 The first line checks the waiting list to see if someone tried to connect to the listen socket. If no one connected then it returns a
\par number smaller than 1. If someone did connect then it creates a new socket and returns its id. This socket will now be used to
\par send and recieve data from the person who just connected. The second argument in tcpaccept means the new socket will
\par be non-blocking. In this case when you are trying to recieve a message it will not freeze the game if their is no message to be
\par recieved.
\par The second line checks if tcpaccept returned an error. If it did then it exits the script.
\par The third line and fourth line will only be executed if their was no error. The thrid line sets the global variable "global.otherplayer"
\par to the socket id that tcpaccept() returned.
\par The fourth line goes to the playing room. (you needed to create that room btw).
\par 
\par }{\b\f1\fs40\insrsid4865889 Connecting to the server.
\par }{\f1\insrsid4865889 To join a multiplayer game we need to connect to a server. In the room where you have the button "Host" and the button "Connect", make
\par it so when the player clicks connect it executes this code:
\par }{\i\f1\fs20\insrsid4865889 global.master = false;
\par server = tcpConnect("127.0.0.1", 14804, true);
\par if(server <= 0)
\par \{
\par   show_message("Unable to connect to server");
\par   game_end();
\par \}
\par global.otherplayer = server;
\par room_goto(rmGame);
\par 
\par }{\f1\insrsid4865889 The first line sets the global variable "master" to false. This is because we are not the server. We are the client connecting to the
\par server. The second line makes the actual connection to the server.
\par The first argument in tcpConnect is the ip address you want to connect to. If you are just testing locally use the address "127.0.0.1".
\par The second argument is the port number to connect to. The third argument is wether to use blocking or non blocking mode. We
\par set it true which means non-blocking. This makes it so whenever we try and send or recieve a message, the game doesnt freeze
\par until the operation finished. If tcpConnect succesfully connected and was accepted by the server, the variable "server" should now
\par contain the socket id. If an error occured a number < 1 will be returned.
\par 
\par The next line checks if an error occured. An error could be because the server doesnt exist or the server didnt accept us. If an
\par error did occur then the game will end.
\par 
\par If no error occurs then the global variable "otherplayer" now becomes the socket id that the variable "server" has. Then the game will
\par start when we use room_goto().
\par 
\par }{\b\i\f1\fs40\insrsid4865889 Sending and recieving messages
\par }{\f1\insrsid4865889 For our game to work we need to know the y position of the paddle that the other player controls and the client needs to know the x, y
\par position of the ball which will be controlled by the server.
\par 
\par }{\b\f1\insrsid4865889 Sending
\par }{\f1\insrsid4865889 In the paddle which is controlled by you, you must send your Y co-ordinate to the other player so they can draw your paddle in the
\par right position. To do this, put this code in both the keyboard UP event and the keyboard DOWN event:
\par 
\par }{\i\f1\fs20\insrsid4865889 clearbuffer();
\par writebyte(0);
\par writeshort(y);
\par sendmessage(global.otherplayer);
\par 
\par }{\f1\insrsid4865889 The first line clears the internal buffer of any data. This is used in case there is data already in the buffer. The second line writes the byte
\par that represents the Message Id. In this game the message id 0 will indicate the message containing the Y position.
\par The next line writes the actual Y position to the buffer. We have used the data type "short" because a short can be any number between
\par -32000 to +32000. A short utilizes 2 bytes. If we had used one byte to represent the Y position and the Y position is bigger than 255 it will end up being not what you
\par wanted. The last line sends all the data in the internal buffer to the other player. In this case the data is the Message Id byte and the 2 bytes
\par used for the Y position.
\par 
\par Now we need to send the x, y position to the other player if we are the server. To do this put in the step event of the ball object:
\par 
\par if(!global.master)exit;
\par }{\i\f1\fs20\insrsid4865889 clearbuffer();
\par writebyte(1);
\par writeshort(x);
\par writeshort(y);
\par sendmessage(global.otherplayer);
\par 
\par }{\f1\insrsid4865889 The first line checks to see if we are the server. If we are NOT the server then exit the screen and do not execute the code below.
\par If however we are the server then first clear the internal buffer. Now write the Message Id "1" which will indicate the message is
\par the balls position. Now write a short which represents the x co-ordinate and write another short which represents the y co-ordinate.
\par Now just send the message to the other player.
\par 
\par 
\par }{\b\f1\insrsid4865889 Recieving a message.}{\f1\insrsid4865889 
\par In the paddle that you do not control..the one which is controlled by the other player, put this code in the step event:}{\i\f1\fs20\insrsid4865889 
\par var size;
\par while(true)
\par \{
\par }{\i\f1\fs20\insrsid4865889   size = rec}{\i\f1\fs20\insrsid4865889 e}{\i\f1\fs20\insrsid4865889 i}{\i\f1\fs20\insrsid4865889 vemessage(global.otherplayer);
\par   if(size < 0) break;
\par   if(size == 0)
\par   \{
\par     show_message("The other player left the game");
\par     game_end();
\par   \}
\par   messageid = readbyte();
\par   switch(messageid)
\par   \{
\par     case 0:
\par       y = readshort();
\par     break;
\par     
\par     case 1:
\par       objBall.x = readshort();
\par       objBall.y = readshort();:
\par     break;
\par   \}
\par \}
\par 
\par }{\f1\insrsid4865889 First this creates an infinite loop using while(true). The first line of the loop recieves any messages from the other player and sets the
\par variable "size" to how much bytes we recieved. The second line checks to see if no message was recieved. If no message was recieved
\par then exit the infinite loop. The third line checks to see if the other player disconnected from the game. If the message size == 0 
\par that means the player left the game.
\par If the player did leave, then end the game. If we did recieve a message then all data from the message is placed inside the internal buffer.
\par We can now use the buffer scripts to return the data from the message. The first part returns the message ID.
\par After that it uses the switch() statement to check what the ID equals. If the ID is 0 then this means the message is for the other players
\par y co-ordinate. We simply use readshort() to return the y position. Remember because we wrote the Y position as a short, we now must
\par read the Y position using a short.
\par 
\par If the Message ID equals 1, which represents the balls x, y position then use readshort() to set the balls x position to the right place and
\par readshort() again to set the balls y position in the right place.
\par 
\par }{\b\f1\fs40\insrsid4865889 Freeing the dll
\par }{\f1\insrsid4865889 If you dont want any nasty error messages when your game ends then you must free the dll from memory. To do this first create an object
\par that will be in every room. Now in the game end event of that object just put dllfree(). This will free winsock and free all memory used
\par by the internal buffer.}{\f1\fs20\insrsid4865889 
\par }}